Data structures, as the term implies, are a way of structuring data in order to efficiently store, find, use, and create data, depending on the task at hand. If data is a plate of food, data structures are your utensils (algorithms would be how to effectively use those utensils in this analogy). Just as you will likely select a spoon to eat a bowl of soup rather than a knife, you will learn over time to select and properly use data structures which fit the nature of the data you are working with. When you begin learning basic data structures such as arrays and linked lists, you will start to conceptualize how data is stored, searched, and edited, and what these operations will contribute to the space/time complexity of your program at runtime (this will make more sense once you start to learn about Big O notation). As you continue to learn more complex data structures, you may notice that you need to think more abstractly and deliberately in order to properly implement them. But with patience and practice you will begin to see patterns emerge that will allow you to intuitively see which situation calls for which data structure, just as you know to pick up a spoon when you see a bowl of soup. is Data Structure:
A data structure is a storage that is used to store and organize data. It is a way of arranging data on a computer so that it can be accessed and updated efficiently.



A data structure is not only used for organizing the data. It is also used for processing, retrieving, and storing data. There are different basic and advanced types of data structures that are used in almost every program or software system that has been developed. So we must have good knowledge about data structures. 

Get Hands-on With Data Structures and Algorithms

Master fundamental computer science concepts to solve real-world problems and ace coding interview questions with Educative’s interactive course Data Structures and Algorithms in Python. Sign up at Educative.io with the code GEEKS10 to save 10% on your subscription.

Classification of Data Structure: 
Classification of Data Structure
Classification of Data Structure

Linear data structure: Data structure in which data elements are arranged sequentially or linearly, where each element is attached to its previous and next adjacent elements, is called a linear data structure. 
Examples of linear data structures are array, stack, queue, linked list, etc.
Static data structure: Static data structure has a fixed memory size. It is easier to access the elements in a static data structure. 
An example of this data structure is an array.
Dynamic data structure: In dynamic data structure, the size is not fixed. It can be randomly updated during the runtime which may be considered efficient concerning the memory (space) complexity of the code. 
Examples of this data structure are queue, stack, etc.
Non-linear data structure: Data structures where data elements are not placed sequentially or linearly are called non-linear data structures. In a non-linear data structure, we can’t traverse all the elements in a single run only. 
Examples of non-linear data structures are trees and graphs.
For example, we can store a list of items having the same data-type using the array data structure.

Array Data Structure
Array Data Structure

This page contains detailed tutorials on different data structures (DS) with topic-wise problems.

Introduction to Data Structures:

What is Data Structure: Types, Classifications and Applications
Introduction to Data Structures
Common operations on various Data Structures
Popular types of Data Structures:

Array
Linked List
Stack
Queue
Binary Tree
Binary Search Tree
Heap
Hashing
Graph
Matrix
Misc
Advanced Data Structure
Overview:

Introduction to Linear Data Structures
Introduction to Hierarchical Data Structure
Overview of Data Structures | Set 3 (Graph, Trie, Segment Tree and Suffix Tree)
Abstract Data Types
Linked List:


Singly Linked List:

Introduction to Linked List
Linked List vs Array
Linked List Insertion
Linked List Deletion (Deleting a given key)
Linked List Deletion (Deleting a key at given position)
A Programmer’s approach of looking at Array vs. Linked List
Find Length of a Linked List (Iterative and Recursive)
How to write C functions that modify head pointer of a Linked List?
Swap nodes in a linked list without swapping data
Reverse a linked list
Merge two sorted linked lists
Merge Sort for Linked Lists
Reverse a Linked List in groups of given size
Detect and Remove Loop in a Linked List
Add two numbers represented by linked lists | Set 1
Rotate a Linked List
Generic Linked List in C
Circular Linked List:

Circular Linked List Introduction and Applications,
Circular Singly Linked List Insertion
Circular Linked List Traversal
Split a Circular Linked List into two halves
Sorted insert for circular linked list
Doubly Linked List:

Doubly Linked List Introduction and Insertion
Delete a node in a Doubly Linked List
Reverse a Doubly Linked List
The Great Tree-List Recursion Problem.
QuickSort on Doubly Linked List
Merge Sort for Doubly Linked List
All Articles of Linked List
Coding Practice on Linked List
Recent Articles on Linked List

Stack:

Introduction to Stack
Infix to Postfix Conversion using Stack
Evaluation of Postfix Expression
Reverse a String using Stack
Implement two stacks in an array
Check for balanced parentheses in an expression
Next Greater Element
Reverse a stack using recursion
Sort a stack using recursion
The Stock Span Problem
Design and Implement Special Stack Data Structure
Implement Stack using Queues
Design a stack with operations on middle element
How to efficiently implement k stacks in a single array?
Sort a stack using recursion
All Articles on Stack
Coding Practice on Stack
Recent Articles on Stack

 

Queue:

Queue Introduction and Array Implementation
Linked List Implementation of Queue
Applications of Queue Data Structure
Priority Queue Introduction
Deque (Introduction and Applications)
Implementation of Deque using circular array
Implement Queue using Stacks
Find the first circular tour that visits all petrol pumps
Maximum of all subarrays of size k
An Interesting Method to Generate Binary Numbers from 1 to n
How to efficiently implement k Queues in a single array?
All Articles on Queue
Coding Practice on Queue
Recent Articles on Queue

 

Binary Tree:

Binary Tree Introduction
Binary Tree Properties
Types of Binary Tree
Handshaking Lemma and Interesting Tree Properties
Enumeration of Binary Tree
Applications of tree data structure
Tree Traversals
BFS vs DFS for Binary Tree
Level Order Tree Traversal
Diameter of a Binary Tree
Inorder Tree Traversal without Recursion
Inorder Tree Traversal without recursion and without stack!
Threaded Binary Tree
Maximum Depth or Height of a Tree
If you are given two traversal sequences, can you construct the binary tree?
Clone a Binary Tree with Random Pointers
Construct Tree from given Inorder and Preorder traversals
Maximum width of a binary tree
Print nodes at k distance from root
Print Ancestors of a given node in Binary Tree
Check if a binary tree is subtree of another binary tree
Connect nodes at same level
All articles on Binary Tree
Coding Practice on Binary Tree
Recent Articles on Tree

Binary Search Tree:

Search and Insert in BST
Deletion from BST
Minimum value in a Binary Search Tree
Inorder predecessor and successor for a given key in BST
Check if a binary tree is BST or not
Lowest Common Ancestor in a Binary Search Tree.
Inorder Successor in Binary Search Tree
Find k-th smallest element in BST (Order Statistics in BST)
Merge two BSTs with limited extra space
Two nodes of a BST are swapped, correct the BST
Floor and Ceil from a BST
In-place conversion of Sorted DLL to Balanced BST
Find a pair with given sum in a Balanced BST
Total number of possible Binary Search Trees with n keys
Merge Two Balanced Binary Search Trees
Binary Tree to Binary Search Tree Conversion
All Articles on Binary Search Tree
Coding Practice on Binary Search Tree
Recent Articles on BST

Heap:

Binary Heap
Why is Binary Heap Preferred over BST for Priority Queue?
Heap Sort
K’th Largest Element in an array
Sort an almost sorted array
Binomial Heap
Fibonacci Heap
Tournament Tree (Winner Tree) and Binary Heap
All Articles on Heap
Coding Practice on Heap
Recent Articles on Heap


Hashing:

Hashing Introduction
Separate Chaining for Collision Handling
Open Addressing for Collision Handling
Print a Binary Tree in Vertical Order
Find whether an array is subset of another array
Union and Intersection of two Linked Lists
Find a pair with given sum
Check if a given array contains duplicate elements within k distance from each other
Find Itinerary from a given list of tickets
Find number of Employees Under every Employee
All Articles on Hashing
Coding Practice on Hashing
Recent Articles on Hashing

 

Graph:

Introduction, DFS and BFS:

Graph and its representations
Breadth First Traversal for a Graph
Depth First Traversal for a Graph
Applications of Depth First Search
Applications of Breadth First Traversal
Detect Cycle in a Directed Graph
Detect Cycle in Graph using DSU
Detect cycle in an Undirected Graph using DFS
Longest Path in a Directed Acyclic Graph
Topological Sorting
Check whether a given graph is Bipartite or not
Snake and Ladder Problem
Minimize Cash Flow among a given set of friends who have borrowed money from each other
Boggle (Find all possible words in a board of characters)
Assign directions to edges so that the directed graph remains acyclic
All Articles on Graph Data Structure
Coding Practice on Graph
Recent Articles on Graph

 

Advanced Data Structure:

Advanced Lists:

Memory efficient doubly linked list
XOR Linked List – A Memory Efficient Doubly Linked List | Set 1
XOR Linked List – A Memory Efficient Doubly Linked List | Set 2
Skip List | Set 1 (Introduction)
Self Organizing List | Set 1 (Introduction)
Unrolled Linked List | Set 1 (Introduction)
Segment Tree:

Segment Tree | Set 1 (Sum of given range)
Segment Tree | Set 2 (Range Minimum Query)
Lazy Propagation in Segment Tree
Persistent Segment Tree | Set 1 (Introduction)
All articles on Segment Tree
Trie:

Trie | (Insert and Search)
Trie | (Delete)
Longest prefix matching – A Trie based solution in Java
Print unique rows in a given boolean matrix
How to Implement Reverse DNS Look Up Cache?
How to Implement Forward DNS Look Up Cache?
All Articles on Trie
Binary Indexed Tree:

Binary Indexed Tree
Two Dimensional Binary Indexed Tree or Fenwick Tree
Binary Indexed Tree : Range Updates and Point Queries
Binary Indexed Tree : Range Update and Range Queries
All Articles on Binary Indexed Tree
Suffix Array and Suffix Tree:

Suffix Array Introduction
Suffix Array nLogn Algorithm
kasai’s Algorithm for Construction of LCP array from Suffix Array
Suffix Tree Introduction
Ukkonen’s Suffix Tree Construction – Part 1
Ukkonen’s Suffix Tree Construction – Part 2
Ukkonen’s Suffix Tree Construction – Part 3
Ukkonen’s Suffix Tree Construction – Part 4,
Ukkonen’s Suffix Tree Construction – Part 5
Ukkonen’s Suffix Tree Construction – Part 6
Generalized Suffix Tree
Build Linear Time Suffix Array using Suffix Tree
Substring Check
Searching All Patterns
Longest Repeated Substring,
Longest Common Substring, Longest Palindromic Substring

All Articles on Suffix Tree
AVL Tree:

AVL Tree | Set 1 (Insertion)
AVL Tree | Set 2 (Deletion)
AVL with duplicate keys
Splay Tree:

Splay Tree | Set 1 (Search)
Splay Tree | Set 2 (Insert)
B Tree:

B-Tree | Set 1 (Introduction)
B-Tree | Set 2 (Insert)
B-Tree | Set 3 (Delete)
Red-Black Tree:

Red-Black Tree Introduction
Red Black Tree Insertion.
Red-Black Tree Deletion
Program for Red Black Tree Insertion

All Articles on Self-Balancing BSTs

 

K Dimensional Tree:

KD Tree (Search and Insert)
K D Tree (Find Minimum)
K D Tree (Delete)
Others:

Treap (A Randomized Binary Search Tree)
Ternary Search Tree
Interval Tree
Implement LRU Cache
Sort numbers stored on different machines
Find the k most frequent words from a file
Given a sequence of words, print all anagrams together
Tournament Tree (Winner Tree) and Binary Heap
Decision Trees – Fake (Counterfeit) Coin Puzzle (12 Coin Puzzle)
Spaghetti Stack
Data Structure for Dictionary and Spell Checker?
Cartesian Tree
Cartesian Tree Sorting
Sparse Set
Centroid Decomposition of Tree
Gomory-Hu Tree
Recent Articles on Advanced Data Structures.

Array:

Search, insert and delete in an unsorted array
Search, insert and delete in a sorted array
Write a program to reverse an array
Leaders in an array
Given an array A[] and a number x, check for pair in A[] with sum as x
Majority Element
Find the Number Occurring Odd Number of Times
Largest Sum Contiguous Subarray
Find the Missing Number
Search an element in a sorted and pivoted array
Merge an array of size n into another array of size m+n
Median of two sorted arrays
Program for array rotation
Reversal algorithm for array rotation
Block swap algorithm for array rotation
Maximum sum such that no two elements are adjacent
Sort elements by frequency | Set 1
Count Inversions in an array
Careerdrill Right Data Structure 
Based on requirements, always pick the right tool for the job. — DrewMarsh

 

The data structure is a particular way of organizing data in a computer. The developer must choose the appropriate data structure for better performance. If the developer chooses a bad data structure, the system does not perform well. This article explains each data structure’s advantages and usage.

Linked List
The linked list is a data structure that links each node to the next node. The developer can use the linked list in the following use cases.

When the developer needs constant time for insertion and deletion.
When the data dynamically grows.
Do not access random elements from the linked list.
Insert the element in any position of the list.
Circular Linked List
A circular linked list is a linked list in which the link field of the tail node link to the head node. The developer can use a circular linked list in the following use cases.

Develop the buffer memory.
Represent a deck of cards in a game.
Browser cache allows hitting the BACK button.
Implement the Most Recently Used (MRU) list.
Undo functionality in Photoshop or Word.
Doubly Linked List
Doubly linked is a data structure in which each node contains data and two links. One link point to the previous node and another link point to the next node. The developer can use a doubly linked list in the following uses cases.

Easier to delete the node from the doubly linked list.
It can be iterated in reverse order without recursion implementation.
Insert or remove from double-linked lists faster.
Stack
The stack is a last-in, first-out data structure. The developer can use the stack in the following use cases.

Expression evaluation and syntax parsing.
Finding the correct path in a maze using backtracking.
Runtime memory management.
Recursion function.
Queue
The queue is a first in, first-out (FIFO) data structure. The developer can use Queue in the following use cases.

Use a queue when the developer wants an order.
Processed in First In First Out order.
If the developer wants to add or remove both ends, they can use the queue or a double-ended queue.
Binary Tree
A binary tree is a tree data structure in which each node has at most two child nodes. The developer can use Binary Tree in the following use cases.

Find the name in the phone book.
Sorted traversal of the tree.
Find the next closest element.
Find all elements less than or greater than a certain value.
Binary Search Tree
A binary search tree is a tree data structure in which the root node is less than or equal to the left subtree and greater than or equal to the right subtree. The developer can use Binary Search Tree in the following use cases.

Binary Search Trees are memory-efficient.
Use when the data need to be sorted.
Search can be done for a range of values.
Height balancing helps to reduce the running time.
Heap
A heap is a specialized tree-based abstract data type that satisfies the heap property. The developer can use Heap in the following use cases.

Implement Priority Queue.
whenever the developer wants quick access to the largest (or smallest) item.
Good for selection algorithms (finding the min or max).
Operations tend to be faster than for a binary tree.
Heap sort sorting methods being in-place and with no quadratic worst-case scenarios.
Graph algorithms are using heaps as internal traversal data structures, the run time will be reduced by polynomial order.
Hashing
Hash table is a data structure used to implement an associative array, a structure that can map keys to values. The developer can use a Hash table in the following use cases.

Constant time operation.
Inserts are generally slow, reads are faster than trees.
Hashing is used so that searching a database can be done more efficiently.
Internet routers use hash tables to route the data from one computer to another.
The Internet search engine uses a hash functions effectively.
Graph
The graph is an abstract data type that is meant to implement the graph and directed graph concepts from mathematics. The developer can use Graph in the following use cases.

Networks have many uses in the practical side of graph theory.
Finding the shortest path between the cities.
Solve the maze game.
Find the optimized route between the cities.
Red-Black Tree
Red–black tree is a binary search tree with an extra bit of data per node, its color, which can be either red or black. The developer can use Red-Black Tree in the following use cases.

Java TreeMap and C++ map implemented using Red Block Tree.
Computational Geometry Data structures.
Scheduler applications.
Array
The array is a data structure to store the same type of elements continuously. The developer can use an array in the following use cases.

Need access to the elements using the index.
Know the size of the array before defining the memory.
Speed when iterating through all the elements in the sequence.
The array takes less memory compare than a linked list.
 

Matrix
Matrix is a data structure that stores the data using rows and columns. The developer can use Matrix in the following use cases.

Matrix arithmetic in graphic processing algorithms.
Represent the graph.
Represent quadratic forms and linear algebra solution.
B-Tree
B-tree is a tree data structure that keeps data sorted and allows searches, sequential access, insertions, and deletions in logarithmic time. The developer can use B-Tree in the following use cases.

File systems.
Database operations.
Splay Tree
A splay tree is a self-adjusting binary search tree with the additional property that recently accessed elements are quick to access again. The developer can use Splay Tree in the following use cases.

When the developer wants to access to the recent data easily.
Allow duplicate items.
Simple implementation and take less memory.
When the application deals with a lot of data, use the splay-tree.
AVL Tree
AVL tree, the shape of the tree is constrained at all times such that the tree shape is balanced. The height of the tree never exceeds O(log n). The developer can use AVL Tree in the following use cases.

When the developer wants to control the tree height outside -1 to 1 range.
Fast looking element.
Trie
A Trie (digital tree and sometimes radix tree or prefix tree), is an ordered tree data structure that is used to store a dynamic set or associative array where the keys are usually strings. The developer can use Trie in the following use cases.

Fixed dictionary and want to look up quickly.
Require less storage for a large dictionary.
Matching sentences during string matching.
Predictable O(k) lookup time where k is the size of the key.
Lookup can take less than k time if it’s not there.
Supports ordered traversal.
No need for a hash function.
Deletion is straightforward.
Minimum Spanning Tree
A spanning tree of that graph is a subgraph that is a tree and connects all the vertices together. A minimum spanning tree (MST) or minimum weight spanning tree is then a spanning tree with weight less than or equal to the weight of every other spanning tree. The developer can use Minimum Spanning Tree in the following use cases.

Describe financial markets.
Handwriting recognition of mathematical expressions.
Image registration and segmentation.
Constructing trees for broadcasting in computer networks.
We discussed different data structures and uses cases to choose the appropriate data structure. When the candidate attends the technical coding interview or uses the application programming interface in software development, the candidate must choose the correct data structure. If the candidate uses the incorrect data structure, it may work. But the programs may fail with more data or with the different use cases.
